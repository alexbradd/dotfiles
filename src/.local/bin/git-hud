#! /usr/bin/env python3
"""
Format a quick summary about the current git repository and print it to
standard output
"""

from os import environ
from pathlib import Path
import argparse
import subprocess
import re

DESCRIPTION = ("Format a quick summary about the current git repository and "
               "print it to standard output.\n")

NO_BRANCH_HELP = "do not show branch name"
NO_COMMIT_HELP = "do not show last commit's short hash"
NO_DISTANCE_HELP = "do not show if local branch is ahead or behind remote"
NO_MOD_HELP = "do not show if there are uncomitted changes to the tree"

BRANCH_GLYPH = ''
AHEAD_GLYPH = '↑'
BEHIND_GLYPH = '↓'

TERM = environ.get('TERM')
if TERM == 'linux' or TERM is None:
    BRANCH_GLYPH = 'branch'
    AHEAD_GLYPH = 'ahead '
    BEHIND_GLYPH = 'behind '

EMPTY_REPO = "## No commits yet on master"


def main():
    """Main function"""
    args = setup_args()
    git_dir = get_root_dir()
    if git_dir is None:
        return
    else:
        prompt = construct_prompt(git_dir, args.no_branch, args.no_commit,
                                  args.no_distance, args.no_mod)
        print(prompt)


def setup_args():
    """Return namespace with parsed args"""
    parser = argparse.ArgumentParser(prog='git-hud', description=DESCRIPTION)
    parser.add_argument('-B',
                        '--no_branch',
                        action='store_true',
                        help=NO_BRANCH_HELP)
    parser.add_argument('-C',
                        '--no_commit',
                        action='store_true',
                        help=NO_COMMIT_HELP)
    parser.add_argument('-D',
                        '--no_distance',
                        action='store_true',
                        help=NO_DISTANCE_HELP)
    parser.add_argument('-M',
                        '--no_mod',
                        action='store_true',
                        help=NO_MOD_HELP)
    return parser.parse_args()


def get_root_dir():
    """Get repo root directory"""
    try:
        proc = subprocess.run(["git", "rev-parse", "--show-toplevel"],
                              text=True,
                              check=True,
                              stdout=subprocess.PIPE,
                              stderr=subprocess.STDOUT)
        return Path(proc.stdout.strip())
    except subprocess.CalledProcessError:
        return None


def construct_prompt(root_dir, no_branch, no_commit, no_distance, no_mod):
    """Format prompt"""
    prompt = ""
    repo_info = get_repo_info()
    if repo_info is not None:
        if not no_branch:
            prompt += f'{BRANCH_GLYPH} {get_branch(repo_info)} '
        if not no_commit:
            prompt += f'({get_latest_commit()}) '
        if not no_distance:
            ahead, behind = get_ahead_behind(repo_info)
            if ahead == 0 and behind == 0:
                prompt += f'{AHEAD_GLYPH}{BEHIND_GLYPH} '
            else:
                prompt += f'{AHEAD_GLYPH}{ahead} {BEHIND_GLYPH}{behind} '
        if not no_mod:
            mods = f'[{get_staged(repo_info)}'
            mods += f'{get_unstaged(repo_info)}'
            mods += f'{get_untracked(repo_info)}'
            mods += f'{get_unmerged(repo_info)}'
            mods += f'{get_stashed(root_dir)}] '
            if mods != '[] ':
                prompt += mods
    return prompt


def get_repo_info():
    """Return output of git status --porcelain --branch"""
    try:
        proc = subprocess.run(["git", "status", "--porcelain", "--branch"],
                              check=True,
                              text=True,
                              stdout=subprocess.PIPE,
                              stderr=subprocess.STDOUT)
        return proc.stdout.strip()
    except subprocess.CalledProcessError:
        return None


def get_branch(repo_info):
    """Extract branch from repo_info (obtained from get_repo_info)"""
    first_line = repo_info.splitlines()[0]
    branch = ""
    if first_line == EMPTY_REPO:
        return "???"
    else:
        branch = first_line.split()[1]  # ex: branch...origin
        branch = branch.split("...")[0]  # ex: branch
        return branch


def get_ahead_behind(repo_info):
    """Extract from repo_info number of commits ahead/behind remote"""
    first_line = repo_info.splitlines()[0]
    ahead_behind_match = re.search(r'\[.*\]', first_line)  # [ahead 1 behind 1]
    if ahead_behind_match is None:
        return 0, 0
    else:
        ahead_behind_str = ahead_behind_match.group(0)
        ahead_match = re.search(r'(?<=ahead) +[0-9]+', ahead_behind_str)
        behind_match = re.search(r'(?<=behind) +[0-9]+', ahead_behind_str)
        ahead, behind = (0, 0)
        if ahead_match is not None:
            ahead = int(ahead_match.group(0).strip())
        if behind_match is not None:
            behind = int(behind_match.group(0).strip())
        return ahead, behind


def get_latest_commit():
    """Get latest commit short hash"""
    try:
        proc = subprocess.run(["git", "rev-parse", "HEAD"],
                              text=True,
                              check=True,
                              stdout=subprocess.PIPE,
                              stderr=subprocess.STDOUT)
        return proc.stdout.strip()[0:7]
    except subprocess.CalledProcessError:
        return '???'


def get_unstaged(repo_info):
    """
    Extract from repo_info using regex if there are unstaged changes and
    return corresponding glyph
    """
    return '*' if re.findall(r'(?m)^.[DMARC]', repo_info) else ''


def get_staged(repo_info):
    """
    Extract from repo_info using regex if there are staged changes and
    return corresponding glyph
    """
    return '+' if re.findall(r'(?m)^[DMARC].', repo_info) else ''


def get_untracked(repo_info):
    """
    Extract from repo_info using regex if there are untracked files and
    return corresponding glyph
    """
    return '?' if re.findall(r'(?m)^\?\?', repo_info) else ''


def get_unmerged(repo_info):
    """
    Extract from repo_info using regex if there are merge conflicts and
    return corresponding glyph
    """
    return '!' if re.findall(r'(?m)^[DAU]{2}', repo_info) else ''


def get_stashed(git_root_dir):
    """
    Extract from repo_info using regex if there are stashed changes and
    return corresponding glyph
    """
    return '$' if Path(git_root_dir, '.git/refs/stash').is_file() else ''


if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        pass
